#!/usr/bin/env python3
"""
Convert an animated GIF (or single/multiple PNG frames) into packed 1bpp C header(s)
suitable for SSD1306-style monochrome displays (row-major, MSB-first).

Outputs a header file with:
 - #pragma once
 - static const uint8_t <name>_frames[][BYTES_PER_FRAME] = { ... };
 - static const unsigned <name>_frame_count = N;

Usage example:
    python3 tools/convert_gif_to_mono.py \
      --input assets/animation.gif \
      --out boards/shields/nice_view_press_start/include/images/animation1_frames_mono.h \
      --name animation1 --width 128 --height 64 --dither floyd

Requires Pillow:
    pip3 install pillow

Dither options:
 - none   : simple threshold (128)
 - floyd  : Floyd-Steinberg (Pillow default)
 - ordered: 4x4 Bayer ordered dither
"""

import argparse
import os
from PIL import Image, ImageSequence

BAYER_4x4 = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]


def pack_1bpp_from_binary_image(img):
    """
    img: PIL Image in mode '1' (black/white) or 'L' (0..255) where 0 is black, 255 white.
    Returns: bytes packed row-major MSB-first, 8 pixels per byte.
    """
    if img.mode != "1":
        # Convert to '1' expecting 0/255 values (should be already binary)
        binary = img.convert("1")
    else:
        binary = img

    w, h = binary.size
    pixels = binary.load()
    out = bytearray()
    for y in range(h):
        byte = 0
        bits = 0
        for x in range(w):
            p = pixels[x, y]  # 0 or 255
            bit = 1 if p != 0 else 0  # 1 = white/on
            byte = (byte << 1) | bit
            bits += 1
            if bits == 8:
                out.append(byte & 0xFF)
                byte = 0
                bits = 0
        if bits != 0:
            # pad the remaining bits on the right (LSB)
            byte = byte << (8 - bits)
            out.append(byte & 0xFF)
    return bytes(out)


def ordered_dither(img_l):
    """
    img_l: PIL Image in 'L' mode (grayscale)
    Returns: PIL Image in mode '1' after 4x4 Bayer ordered dithering.
    """
    w, h = img_l.size
    out = Image.new("1", (w, h))
    src = img_l.load()
    dst = out.load()
    for y in range(h):
        for x in range(w):
            v = src[x, y]  # 0..255
            # normalize Bayer threshold to 0..255 range
            m = BAYER_4x4[y % 4][x % 4]
            threshold = int((m + 0.5) * (255.0 / 16.0))
            dst[x, y] = 255 if v > threshold else 0
    return out


def convert_frame(frame, width, height, dither):
    """
    Convert a single PIL frame to a binary ('1') image with requested output size.
    Uses cover/crop strategy: scales to fill and center-crops.
    """
    # Flatten alpha onto white background to preserve intended artwork
    frame_rgba = frame.convert("RGBA")
    bg = Image.new("RGBA", frame_rgba.size, (255, 255, 255, 255))
    bg.paste(frame_rgba, (0, 0), frame_rgba)

    src_w, src_h = bg.size
    # Scale to cover target (no letterbox): use max scale
    scale = max(width / src_w, height / src_h)
    new_w = max(1, int(round(src_w * scale)))
    new_h = max(1, int(round(src_h * scale)))
    img = bg.resize((new_w, new_h), Image.LANCZOS)

    # Center-crop to target size
    left = (new_w - width) // 2
    top = (new_h - height) // 2
    img = img.crop((left, top, left + width, top + height))

    # Convert to grayscale for dithering/thresholding
    img_l = img.convert("L")

    if dither == "none":
        # simple threshold
        img_1 = img_l.point(lambda p: 255 if p > 127 else 0, "1")
    elif dither == "floyd":
        # Floyd-Steinberg dithering via Pillow convert (default dithering)
        img_1 = img_l.convert("1")  # uses Floyd by default
    elif dither == "ordered":
        img_1 = ordered_dither(img_l)
    else:
        # fallback to threshold
        img_1 = img_l.point(lambda p: 255 if p > 127 else 0, "1")

    return img_1


def write_header(out_path, name, frames_packed, width, height):
    # bytes per row for packed representation (ceil(width/8))
    bytes_per_row = (width + 7) // 8
    fb_bytes = bytes_per_row * height
    basename = os.path.basename(out_path)
    # Ensure directory exists
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w") as f:
        f.write("#pragma once\n\n")
        f.write("#include <stdint.h>\n\n")
        f.write("/* Generated by tools/convert_gif_to_mono.py\n")
        f.write("   Source: %s\n" % basename)
        f.write(
            "   Frames: %d, Size: %dx%d, Bytes/frame: %d\n"
            % (len(frames_packed), width, height, fb_bytes)
        )
        f.write("*/\n\n")
        # Write the 2D array
        f.write("static const uint8_t %s_frames[][ %d ] = {\n" % (name, fb_bytes))
        for i, frame in enumerate(frames_packed):
            f.write("    {")
            # 12 bytes per line for readability
            for b_idx, b in enumerate(frame):
                if b_idx % 12 == 0:
                    f.write("\n        ")
                f.write("0x%02X, " % b)
            f.write("\n    },\n")
        f.write("};\n\n")
        f.write(
            "static const unsigned %s_frame_count = %d;\n" % (name, len(frames_packed))
        )
    print("Wrote", out_path, "with", len(frames_packed), "frames.")


def gather_frames_from_input(input_path):
    """
    Accepts GIF (animated) or single-image file.
    Returns a list of PIL frames.
    """
    im = Image.open(input_path)
    frames = []
    try:
        # If animated, iterate frames; otherwise, single-frame sequence
        for frame in ImageSequence.Iterator(im):
            frames.append(frame.copy())
    finally:
        im.close()
    return frames


def main():
    p = argparse.ArgumentParser(
        description="Convert GIF/PNG frames to packed 1bpp C header for SSD1306"
    )
    p.add_argument("--input", "-i", required=True, help="Input GIF or image file")
    p.add_argument("--out", "-o", required=True, help="Output .h path")
    p.add_argument(
        "--name",
        "-n",
        default="animation1",
        help="Base name to use in the generated header",
    )
    p.add_argument("--width", type=int, default=128, help="Output width (pixels)")
    p.add_argument("--height", type=int, default=64, help="Output height (pixels)")
    p.add_argument(
        "--dither",
        choices=["none", "ordered", "floyd"],
        default="floyd",
        help="Dither mode",
    )
    args = p.parse_args()

    if not os.path.exists(args.input):
        print("Input not found:", args.input)
        return

    print("Loading frames from", args.input)
    frames = gather_frames_from_input(args.input)
    if len(frames) == 0:
        print("No frames found.")
        return

    print(
        "Converting %d frames -> %dx%d, dither=%s"
        % (len(frames), args.width, args.height, args.dither)
    )
    packed_frames = []

    # expected bytes per frame: bytes_per_row * height
    expected_len = ((args.width + 7) // 8) * args.height

    for idx, fr in enumerate(frames):
        try:
            img1 = convert_frame(fr, args.width, args.height, args.dither)
            packed = pack_1bpp_from_binary_image(img1)
            if len(packed) != expected_len:
                raise RuntimeError(
                    "Packed size mismatch: got %d expected %d"
                    % (len(packed), expected_len)
                )
            packed_frames.append(packed)
            print("  frame %d -> %d bytes" % (idx, len(packed)))
        except Exception as e:
            print("  ERROR converting frame %d: %s" % (idx, e))

    write_header(args.out, args.name, packed_frames, args.width, args.height)


if __name__ == "__main__":
    main()
